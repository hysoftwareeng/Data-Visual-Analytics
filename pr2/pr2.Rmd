---
title: 'Project 2: Modeling and Evaluation'
subtitle: "CSE6242 - Data and Visual Analytics - Summer 2018\n\nDue: Sunday, July 29, 2018 at 11:59 PM UTC-12:00 on T-Square\n\n hyang390, 903320189"
output:
  pdf_document: default
  html_document:
    code_folding: none
    theme: default
  html_notebook:
    code_folding: none
    theme: default
---

# Data

We will use the same dataset as Project 1: [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged).

# Objective

Your goal in this project is to build a linear regression model that can predict the `Gross` revenue earned by a movie based on other variables. You may use R packages to fit and evaluate a regression model (no need to implement regression yourself). Please stick to linear regression, however.

# Instructions

You should be familiar with using an [RMarkdown](http://rmarkdown.rstudio.com) Notebook by now. Remember that you have to open it in RStudio, and you can run code chunks by pressing *Cmd+Shift+Enter*.

Please complete the tasks below and submit this R Markdown file (as **pr2.Rmd**) containing all completed code chunks and written responses, and a PDF export of it (as **pr2.pdf**) which should include the outputs and plots as well.

_Note that **Setup** and **Data Preprocessing** steps do not carry any points, however, they need to be completed as instructed in order to get meaningful results._

# Setup

Same as Project 1, load the dataset into memory:

```{r}
load('movies_merged')
```

This creates an object of the same name (`movies_merged`). For convenience, you can copy it to `df` and start using it:

```{r}
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
```

## Load R packages

Load any R packages that you will need to use. You can come back to this chunk, edit it and re-run to load any additional packages later.

```{r}
library(ggplot2)
library(dplyr)
```

If you are using any non-standard packages (ones that have not been discussed in class or explicitly allowed for this project), please mention them below. Include any special instructions if they cannot be installed using the regular `install.packages('<pkg name>')` command.

**Non-standard packages used**: None

# Data Preprocessing

Before we start building models, we should clean up the dataset and perform any preprocessing steps that may be necessary. Some of these steps can be copied in from your Project 1 solution. It may be helpful to print the dimensions of the resulting dataframe at each step.

## 1. Remove non-movie rows

```{r}
# TODO: Remove all rows from df that do not correspond to movies
df2 = df[df$Type == "movie",]
dim(df2)
```

## 2. Drop rows with missing `Gross` value

Since our goal is to model `Gross` revenue against other variables, rows that have missing `Gross` values are not useful to us.

```{r}
# TODO: Remove rows with missing Gross value
df2 = df2[!is.na(df2$Gross), ]
dim(df2)
```

## 3. Exclude movies released prior to 2000

Inflation and other global financial factors may affect the revenue earned by movies during certain periods of time. Taking that into account is out of scope for this project, so let's exclude all movies that were released prior to the year 2000 (you may use `Released`, `Date` or `Year` for this purpose).

```{r}
# TODO: Exclude movies released prior to 2000
df2 = df2[df2$Year >= 2000, ]
dim(df2)
```

## 4. Eliminate mismatched rows

_Note: You may compare the `Released` column (string representation of release date) with either `Year` or `Date` (numeric representation of the year) to find mismatches. The goal is to avoid removing more than 10% of the rows._

```{r}
# TODO: Remove mismatched rows
df_mismatches = df2
df_mismatches$Released_Year = as.numeric(format(as.Date(df_mismatches$Released, format = "%Y-%m-%d"), "%Y"))
df_mismatches$removal = 1
for (i in seq(1:nrow(df_mismatches))) {
  if (is.na(df_mismatches$Date[i]) & is.na(df_mismatches$Released_Year[i])) {
    df_mismatches$removal[i] = 0
  }
  if (!is.na(df_mismatches$Date[i]) & !is.na(df_mismatches$Released_Year[i])) {
    if ((df_mismatches$Date[i] == df_mismatches$Released_Year[i]) | (abs(df_mismatches$Date[i] - df_mismatches$Released_Year[i]) == 1)) {
      df_mismatches$removal[i] = 0
    }
  }
}

df2 = subset(df_mismatches, removal == 0)
df2 = subset(df2, select=-c(removal, Released_Year))
dim(df2)


```

## 5. Drop `Domestic_Gross` column

`Domestic_Gross` is basically the amount of revenue a movie earned within the US. Understandably, it is very highly correlated with `Gross` and is in fact equal to it for movies that were not released globally. Hence, it should be removed for modeling purposes.

```{r}
# TODO: Exclude the `Domestic_Gross` column
df2 = subset(df2, select=-c(Domestic_Gross))
dim(df2)
```

## 6. Process `Runtime` column

```{r}
# TODO: Replace df$Runtime with a numeric column containing the runtime in minutes
convertRuntime = function(timestr) {
  split_strtime = strsplit(timestr, "\\s+")[[1]]
  if (length(split_strtime) == 2) {
    if (split_strtime[2] == "min") {
      time = as.numeric(split_strtime[1])
    }
    else if (split_strtime[2] == "h") {
      time = as.numeric(split_strtime[1])*60
    }
  }
  else if (length(split_strtime) == 4) {
    time = as.numeric(split_strtime[1])*60 + as.numeric(split_strtime[3])
  }
  else {
    time = suppressWarnings(as.numeric(split_strtime[1]))
  }
  return (time)
}

df2$Runtime = sapply(df2$Runtime, convertRuntime)
dim(df2)
```

Perform any additional preprocessing steps that you find necessary, such as dealing with missing values or highly correlated columns (feel free to add more code chunks, markdown blocks and plots here as necessary).

```{r, warning=FALSE}
# TODO(optional): Additional preprocessing
df2$Metascore = as.numeric(as.character(df2$Metascore))
dim(df2)
```

_**Note**: Do NOT convert categorical variables (like `Genre`) into binary columns yet. You will do that later as part of a model improvement task._

## Final preprocessed dataset

Report the dimensions of the preprocessed dataset you will be using for modeling and evaluation, and print all the final column names. (Again, `Domestic_Gross` should not be in this list!)

```{r}
# TODO: Print the dimensions of the final preprocessed dataset and column names
cat("The final preprocessed dataset has", dim(df2)[1], "rows,", dim(df2)[2], "columns", end="\n", file="")
cat("The column names in the final preprocessed dataset are:", end="\n", file="")
colnames(df2)
```

# Evaluation Strategy

In each of the tasks described in the next section, you will build a regression model. In order to compare their performance, you will compute the training and test Root Mean Squared Error (RMSE) at different training set sizes.

First, randomly sample 10-20% of the preprocessed dataset and keep that aside as the **test set**. Do not use these rows for training! The remainder of the preprocessed dataset is your **training data**.

Now use the following evaluation procedure for each model:

- Choose a suitable sequence of training set sizes, e.g. 10%, 20%, 30%, ..., 100% (10-20 different sizes should suffice). For each size, sample that many inputs from the training data, train your model, and compute the resulting training and test RMSE.
- Repeat your training and evaluation at least 10 times at each training set size, and average the RMSE results for stability.
- Generate a graph of the averaged train and test RMSE values as a function of the train set size (%), with optional error bars.

You can define a helper function that applies this procedure to a given set of features and reuse it.

# Tasks

Each of the following tasks is worth 20 points, for a total of 100 points for this project. Remember to build each model as specified, evaluate it using the strategy outlined above, and plot the training and test errors by training set size (%).

## 1. Numeric variables

Use Linear Regression to predict `Gross` based on available _numeric_ variables. You can choose to include all or a subset of them.

```{r, warning=FALSE}
# TODO: Build & evaluate model 1 (numeric variables only)
rmse_training = function(model){
  residual = residuals(model)
  RMSE=sqrt(mean(residual^2))
  return (RMSE)
}

rmse_testing = function(model, df_testing){
  prediction = predict(model, df_testing)
  actual = df_testing$Gross
  residual = prediction-actual
  RMSE = sqrt(mean(residual[!is.na(residual)]^2))
  return (RMSE)
}

rmse_calculation = function(df_training, df_testing, percent, seed) {
  vec_training = vector(mode="numeric", length = 10)
  vec_testing = vector(mode="numeric", length = 10)
  for (i in 1:length(loop_seeds)) {
    set.seed(loop_seeds[i])
    df_training = df_training[1:(percent*nrow(df_training)), ]
    model = lm(Gross~., df_training)
    vec_training[i] = rmse_training(model)
    vec_testing[i] = rmse_testing(model, df_testing)
  }
  mean_training = mean(vec_training)
  mean_testing = mean(vec_testing)
  set.seed(100)
  return (c(mean_training, mean_testing))
}

model_helper = function(df_data) {
  #sample 20% of the data for testing, 80% for training
  df_randomized = df_data[sample(nrow(df_data)), ]
  df_testing = df_randomized[1:(0.2*nrow(df_randomized)), ]
  df_training = df_randomized[(nrow(df_testing)+1):nrow(df_randomized), ]
  
  percentages = seq(0.1, 1, by=0.1)
  vec_mean_training = vector(mode="numeric", length = 10)
  vec_mean_testing = vector(mode="numeric", length = 10)
  for (i in 1:length(percentages)) {
    model_result = rmse_calculation(df_training, df_testing, percentages[i])
    vec_mean_training[i] = model_result[1]
    vec_mean_testing[i] = model_result[2]
  }
  
  df_result = data.frame(percentages*100, vec_mean_training, vec_mean_testing)
  colnames(df_result) = c("percentage", "training_RMSE", "testing_RMSE")
  return (df_result)
}

min_rmse = function(df_result) {
  min_training_rmse = min(df_result$training_RMSE)
  min_testing_rmse = min(df_result$testing_RMSE)
  return (c(min_training_rmse, min_testing_rmse))
}

set.seed(100)
loop_seeds = seq(11, 110, 10)

df_numeric = select_if(df2, is.numeric)
df_result1 = model_helper(df_numeric)
```

```{r}
ggplot(df_result1, aes(percentage)) + geom_line(aes(y=training_RMSE,color="Training Set"))+
geom_line(aes(y=testing_RMSE,color="Testing Set"))+
labs(title = "Percentage of Training Set vs RMSE for Numeric Values", x= "Percentage of Training size", y = "RMSE")

q1_rmse = min_rmse(df_result1)
```


**Q**: List the numeric variables you used.

**A**: I used the package "dplyr" to select the numeric columns from df2 after preprocessing. The numeric variables used are: Year, Runtime, Metascore, imdbRating, imdbVotes, tomatoMeter, tomatoRating, tomatoReviews, tomatoFresh, tomatoRotten, tomatoUserMeter, tomatoUserRating, tomatoUserReviews, Budget, Date.


**Q**: What is the best mean test RMSE value you observed, and at what training set size?

**A**: The best mean test RMSE observed is 83980311, and this occured at training set size 100%. (Note that this 100% is for the 80% extracted from the original preprocessed dataset) The best mean training RMSE observed is 11769783, occuring at training set size 10%. 


## 2. Feature transformations

Try to improve the prediction quality from **Task 1** as much as possible by adding feature transformations of the numeric variables. Explore both numeric transformations such as power transforms and non-numeric transformations of the numeric variables like binning (e.g. `is_budget_greater_than_3M`).

```{r, warning=FALSE}
# TODO: Build & evaluate model 2 (transformed numeric variables only)
df_q2 = df_numeric
df_q2$imdbVotes = df_q2$imdbVotes^0.6
df_q2$imdbRating = df_q2$imdbRating^4
df_q2$tomatoRating = df_q2$tomatoRating^8
df_q2$tomatoReviews = df_q2$tomatoReviews^2
df_q2$tomatoUserRating = df_q2$tomatoUserRating^1.2
df_q2$tomatoMeter = df_q2$tomatoMeter^2
df_q2$Budget = df_q2$Budget^1.5

df_q2$Runtime_Bin = as.numeric(cut(df_q2$Runtime, 6))
df_q2$Budget_Bin = as.numeric(cut(df_q2$Budget, 6))
df_result2 = model_helper(df_q2)
```

```{r}
ggplot(df_result2, aes(percentage)) + geom_line(aes(y=training_RMSE,color="Training Set"))+
geom_line(aes(y=testing_RMSE,color="Testing Set"))+
labs(title = "Percentage of Training Set vs RMSE for Numeric Values With Transformations", x= "Percentage of Training size", y = "RMSE")

q2_rmse = min_rmse(df_result2)

```

**Q**: Explain which transformations you used and why you chose them.

**A**: I applied both numeric and non-numeric transformations. For numeric transformations, I performed power transformations to fields imdbVotes, imdbRating, tomatoRating, tomatoReviews, tomatoUserRating, tomatoMeter and Budget. Out of all the numeric fields, various trial and error with different power values revealed the relationships between these numeric fields and "Gross" could be somewhat linear with various degrees of power transformations. I did not find a suitable case to apply the log transformation to any of the numeric fields as the results do not seem to provide a better relationship for analysis.

As for non-numeric transformations, I binned both "Runtime" and "Budget". These fields have a large range of values, and binning them will make the relationship with "Gross" easier to analyze. 


**Q**: How did the RMSE change compared to Task 1?

**A**: First, the minimum RMSE for the testing set is 83844040 occuring at when the training set is 100%, and the minimum RMSE for the training set is 10667599 occuring at 10% of the training set. 

Compared to Task 1, both RMSEs are now less with the feature transformations, the value of the testing set in Task 1 was 83980311, and 11769783 for the training set. 

## 3. Non-numeric variables

Write code that converts genre, actors, directors, and other categorical variables to columns that can be used for regression (e.g. binary columns as you did in Project 1). Also process variables such as awards into more useful columns (again, like you did in Project 1). Now use these converted columns only to build your next model.

```{r, warning=FALSE}
# TODO: Build & evaluate model 3 (converted non-numeric variables only)

df_cat = subset(df2, select=c(Rated, Genre, Director, Writer, Actors, Country, Awards, Production, Language, Gross))
###### Process Rated #############
ratings = unlist(strsplit(df_cat$Rated, ','))
ratings = tolower(gsub(' ', '', ratings))
ratings = names(sort(table(ratings), decreasing = TRUE)[1:6])

ratings_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(ratings)))
colnames(ratings_df) = ratings
df_cat$ratings_mod = tolower(gsub(' ', '', df_cat$Rated))
if ("Rated" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Rated))
}

ratings_df[,] = 0
for (item in ratings) {
  ratings_df[grep(item, df_cat[,"ratings_mod"]), item] = 1
}
colnames(ratings_df)[colnames(ratings_df) == "n/a"] = "notavailable"
ratings_df = subset(ratings_df, select=-c(notavailable))

df_cat = cbind(df_cat, ratings_df)
df_cat = subset(df_cat, select=-c(ratings_mod))

###### Process Genre #############
genres = unlist(strsplit(df_cat$Genre, ','))
genres = tolower(gsub(' ', '', genres))
genres = unique(genres)

genres_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(genres)))
colnames(genres_df) = genres
df_cat$Genres_mod = tolower(gsub(' ', '', df_cat$Genre))
if ("Genre" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Genre))
}

genres_df[,] = 0
for (item in genres) {
  genres_df[grep(item, df_cat[,"Genres_mod"]), item] = 1
}
colnames(genres_df)[colnames(genres_df) == "n/a"] = "notavailable"
genres_df = subset(genres_df, select=-c(notavailable))
df_cat = cbind(df_cat, genres_df)
df_cat = subset(df_cat, select=-c(Genres_mod))

###### Process Director #############
directors = unlist(strsplit(df_cat$Director, ','))
directors = tolower(gsub(' ', '', directors))
directors = names(sort(table(directors), decreasing = TRUE)[1:10])

directors_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(directors)))
colnames(directors_df) = directors
df_cat$Directors_mod = tolower(gsub(' ', '', df_cat$Director))
if ("Director" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Director))
}

directors_df[,] = 0
for (item in directors) {
  directors_df[grep(item, df_cat[,"Directors_mod"]), item] = 1
}

df_cat = cbind(df_cat, directors_df)
df_cat = subset(df_cat, select=-c(Directors_mod))

###### Process Writer #############
writers = unlist(strsplit(df_cat$Writer, ','))
writers = tolower(gsub(' ', '', writers))
writers = gsub("\\(|\\)", "", writers)
writers = gsub('screenplay', '', writers)
writers = gsub('story', '', writers)
writers = gsub('novel', '', writers)
writers = names(sort(table(writers), decreasing = TRUE)[1:10])

df_cat$Writers_mod = tolower(gsub(' ', '', df_cat$Writer))
df_cat$Writers_mod = gsub("\\(|\\)", "", df_cat$Writers_mod)
df_cat$Writers_mod = gsub('screenplay', '', df_cat$Writers_mod)
df_cat$Writers_mod = gsub('story', '', df_cat$Writers_mod)
df_cat$Writers_mod = gsub('novel', '', df_cat$Writers_mod)

writers_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(writers)))
colnames(writers_df) = writers
if ("Writer" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Writer))
}

writers_df[,] = 0
for (item in writers) {
  directors_df[grep(item, df_cat[,"Writers_mod"]), item] = 1
}

colnames(writers_df)[colnames(writers_df) == "n/a"] = "notavailable"
writers_df = subset(writers_df, select=-c(notavailable))

df_cat = cbind(df_cat, writers_df)
df_cat = subset(df_cat, select=-c(Writers_mod))


###### Process Actors #############
actors = unlist(strsplit(df_cat$Actors, ','))
actors = tolower(gsub(' ', '', actors))
actors = names(sort(table(actors), decreasing = TRUE)[1:10])

actors_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(actors)))
colnames(actors_df) = actors
df_cat$Actors_mod = tolower(gsub(' ', '', df_cat$Actors))
if ("Actors" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Actors))
}

actors_df[,] = 0
for (item in actors) {
  actors_df[grep(item, df_cat[,"Actors_mod"]), item] = 1
}

df_cat = cbind(df_cat, actors_df)
df_cat = subset(df_cat, select=-c(Actors_mod))

###### Process Country #############


countries = unlist(strsplit(df_cat$Country, ','))
countries = tolower(gsub(' ', '', countries))
countries = names(sort(table(countries), decreasing = TRUE)[1:5])

countries_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(countries)))
colnames(countries_df) = countries
df_cat$countries_mod = tolower(gsub(' ', '', df_cat$Country))
if ("Country" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Country))
}

countries_df[,] = 0
for (item in countries) {
  countries_df[grep(item, df_cat[,"countries_mod"]), item] = 1
}

df_cat = cbind(df_cat, countries_df)
df_cat = subset(df_cat, select=-c(countries_mod)) 


###### Process Production ##########
productions = unlist(strsplit(df_cat$Production, ','))
productions = tolower(gsub(' ', '', productions))
productions = names(sort(table(productions), decreasing = TRUE)[1:6]) #n/a is in top 5, so select 6

productions_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(productions)))
colnames(productions_df) = productions
df_cat$productions_mod = tolower(gsub(' ', '', df_cat$Production))
if ("Production" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Production))
}

productions_df[,] = 0
for (item in productions) {
  productions_df[grep(item, df_cat[,"productions_mod"]), item] = 1
}

colnames(productions_df)[colnames(productions_df) == "n/a"] = "notavailable"
productions_df = subset(productions_df, select=-c(notavailable))

df_cat = cbind(df_cat, productions_df)
df_cat = subset(df_cat, select=-c(productions_mod))

###### Process Awards #############

df_cat$Awards_mod = tolower(df_cat$Awards)
df_cat$Awards_Split = strsplit(df_cat$Awards_mod, "\\,|\\ |\\.|\\&")

different_win_nominations=vector()
for (i in seq(1:nrow(df_cat))) {
  awards_vector = unlist(df_cat$Awards_Split[i])
  wins= 0
  noms = 0
  if ("win" %in% awards_vector) {
    index = which(awards_vector == "win")
    wins= wins + as.integer(awards_vector[index-1])
  }
  if ("wins" %in% awards_vector) {
    index = which(awards_vector == "wins")
    wins= wins + as.integer(awards_vector[index-1])
  }
  if ("won" %in% awards_vector) {
    index = which(awards_vector == "won")
    wins= wins + as.integer(awards_vector[index+1])
  }
  if ("nominated" %in% awards_vector) {
    index = which(awards_vector == "nominated")
    noms= noms + as.integer(awards_vector[index+2])
  }
  if ("nomination" %in% awards_vector) {
    index = which(awards_vector == "nomination")
    noms= noms + as.integer(awards_vector[index-1])
  }
  if ("nominations" %in% awards_vector) {
    index = which(awards_vector == "nominations")
    noms= noms + as.integer(awards_vector[index-1])
  }
  df_cat$Awards_Won[i] = wins
  df_cat$Awards_Nom[i] = noms
}
df_cat = subset(df_cat, select=-c(Awards, Awards_mod, Awards_Split))

###### Process Languages #############
languages = unlist(strsplit(df_cat$Language, ','))
languages = tolower(gsub(' ', '', languages))
languages = names(sort(table(languages), decreasing = TRUE)[1:5])

languages_df = data.frame(matrix(nrow = nrow(df_cat), ncol = length(languages)))
colnames(languages_df) = languages
df_cat$languages_mod = tolower(gsub(' ', '', df_cat$Language))
if ("Language" %in% colnames(df_cat)){
  df_cat = subset(df_cat, select=-c(Language))
}

languages_df[,] = 0
for (item in languages) {
  languages_df[grep(item, df_cat[,"languages_mod"]), item] = 1
}

df_cat = cbind(df_cat, languages_df)
df_cat = subset(df_cat, select=-c(languages_mod)) 
df_q3 = df_cat
df_result3 = model_helper(df_q3)
```

```{r}
ggplot(df_result3, aes(percentage)) + geom_line(aes(y=training_RMSE,color="Training Set"))+
geom_line(aes(y=testing_RMSE,color="Testing Set"))+
labs(title = "Percentage of Training Set vs RMSE for Categorical Variables", x= "Percentage of Training size", y = "RMSE")

q3_rmse = min_rmse(df_result3)
```


**Q**: Explain which categorical variables you used, and how you encoded them into features.

**A**: For this task, I used the categorical variables: Rated, Genre, Director, Writer, Actors, Country, Language, Awards and Production.

First, I created a new dataframe for just the categorical variables selected above. 

For Rated, I first split the strings of Rated in the dataframe and preprocessed the values by replacing spaces and making everything lower case. Then I grouped them and only retrieved the values of the top 5 most popular ratings. I also created a new modified rated column in the dataframe for pattern matching. Then, for each of these 5 ratings, I assigned a value of 1 to a new column with the rating name in the category dataframe if the rows were matched, 0 otherwise. The intermediate modified rating column and the original Rated column were both removed, and the newly created columns were merged back to the category dataframe. A similiar process was done for Genre (top 10), Director (top 10), Writer (top 10), Actors (top 10), Country (top 5), Language(top 5), albeit selecting either top 5/top 10 as specified in the parentheses.


For wards, I first split the string for Awards into into string vectors. Then, I iterated through all the rows in the dataframe one by one, initializing the number of wins and nominations to 0. Then unlisted the vector into strings. Then, I looked for keywords in the unlisted strings. I know from looking at the Awards column that the number precedes keywords "win" and "wins", and succeeds "won". So I looked for these keywords then found the number index position accordingly. These are then accumulated to the current wins. A similiar technique was used for nominations with the keywords "nomination", "nominations" and "nominated". These values are then set to two new columns in the category dataframe for the current row. 

**Q**: What is the best mean test RMSE value you observed, and at what training set size? How does this compare with Task 2?

**A**: The best mean test RMSE value observed is 128590471, occuring at 100% of the training set. The best mean training RMSE observed is 11806496, again occuring at 10% of the training set. This is a big difference compared to Task 2, with an approximately 50% increase in RMSE for the testing set. 


## 4. Numeric and categorical variables

Try to improve the prediction quality as much as possible by using both numeric and non-numeric variables from **Tasks 2 & 3**.

```{r, warning=FALSE}
# TODO: Build & evaluate model 4 (numeric & converted non-numeric variables)
df_q2_mod = subset(df_q2, select=-c(Gross))
df_q4 = cbind(df_q2_mod, df_q3)
df_result4 = model_helper(df_q4)

```

```{r}
ggplot(df_result4, aes(percentage)) + geom_line(aes(y=training_RMSE,color="Training Set"))+
geom_line(aes(y=testing_RMSE,color="Testing Set"))+
labs(title = "Percentage of Training Set vs RMSE for Numerical & Categorical Variables", x= "Percentage of Training size", y = "RMSE")

q4_rmse = min_rmse(df_result4)
```


**Q**: Compare the observed RMSE with Tasks 2 & 3.

**A**: For this task, the minimum RMSE observed for the testing set is 82271121, occuring at 100% of the training set. The minimum RMSE observed for the training set is 7556179, again at 10% of the training set. 

Recall the RMSE of the testing set from Task 2 was 83844040, and task 3 was 128590471. Therefore the RMSE observed by combining both numeric and categorical variables yield a much lower RMSE than both of them separately. A similiar observation was observed for the training set as well. This makes sense as the model is able to be trained on more features and the model contains more information for the prediction of the testing set. 


## 5. Additional features

Now try creating additional features such as interactions (e.g. `is_genre_comedy` x `is_budget_greater_than_3M`) or deeper analysis of complex variables (e.g. text analysis of full-text columns like `Plot`).

```{r, warning=FALSE}
# TODO: Build & evaluate model 5 (numeric, non-numeric and additional features)
df_q5 = df_q4

#Budget and genre Interaction
df_q5$budget10m = ifelse(df_q5$Budget > (10000000),1,0)
df_q5$buget10m_action = df_q5$budget10m * df_q5$action
df_q5$buget10m_adventure = df_q5$budget10m * df_q5$adventure
df_q5$buget10m_thriller = df_q5$budget10m * df_q5$thriller

#Cross genre, actors interaction
df_q5$family_comedy = df_q5$family * df_q5$comedy
df_q5$animation_comedy = df_q5$animation * df_q5$comedy
df_q5$thriller_horror = df_q5$thriller * df_q5$horror
df_q5$adventure_action = df_q5$adventure * df_q5$action

df_q5$action_damon = df_q5$action * df_q5$mattdamon
df_q5$action_deniro = df_q5$action * df_q5$robertdeniro
df_q5$action_willis = df_q5$action * df_q5$brucewillis
df_q5$comedy_wilson = df_q5$comedy * df_q5$owenwilson
df_q5$comedy_stiller = df_q5$comedy * df_q5$benstiller
df_q5$family_clooney = df_q5$family * df_q5$georgeclooney
df_q5$adventure_depp = df_q5$adventure * df_q5$johnnydepp

#Cross votes/ratings
df_q5$imdb_tomato = df_q5$imdbRating * df_q5$tomatoRating
df_q5$imdb_rating_votes = df_q5$imdbRating * df_q5$imdbVotes

df_result5 = model_helper(df_q5)

```

```{r}
ggplot(df_result5, aes(percentage)) + geom_line(aes(y=training_RMSE,color="Training Set"))+
geom_line(aes(y=testing_RMSE,color="Testing Set"))+
labs(title = "Percentage of Training Set vs RMSE with Additional Features", x= "Percentage of Training size", y = "RMSE")

q5_rmse = min_rmse(df_result5)
```

**Q**: Explain what new features you designed and why you chose them.

**A**: I added three main categories of features. First, I chose to cross checking budget over 10 million dollars with a few large genres. I crossed this with genres action, adventure, and thriller as these genres usually tend to have larger budgets, hence the positive correlation. I thought these three new features might provide more information to the model.

Second, I crossed some genres together to create interactions, such as comedy with family, thriller with horror, adventure with action. This is meaningful as these genres often go hand in hand and films often belong to these genres together instead of separately. I also crossed some genres with famous actors of that genre, such as Matt Damon, Robert De Niro, Bruce Willis with action films; Johnny Depp with adventure films, etc.

Lastly, I crossed over the ratings of Rotten Tomatoes and IMDB, as we saw in the previous assignment there is a positive correlation between them, similiar for crossing IMDB ratings with votes. 


**Q**: Comment on the final RMSE values you obtained, and what you learned through the course of this project.

**A**: The final minimum RMSE obtained for the testing set is 81795265, occuring at 100% of the training set, and the minimum RMSE for the training set is 7199647, occuring at 10% of the training set again. It is meaningful to know that both of these RMSEs are the smallest out of all the tasks. Therefore this means the feature engineering that was done in this task to cross over some meainingful features was key in improving the RMSE. 

Over the course of this project, I have learned a great deal about linear regression and various aspects of data processing and feature engineering. I learned how important it is to do data cleansing via pre-processing, as this can signifanctly make the analysis of data easier. I also learned the importance of separating categorical variables out to create new features, as well as analyzing numeric variables and how they can predict outcoms. Next, I learned that combining variables, including both numerical and categorical can yield more oppourtunities for the model to improve and thus reducing RMSE. Last but not least, it was eye-opening to learn how important feature engineering is, by creating new features by simply crossing over already existing ones, this could yield better accuracy and lower RMSE. 

